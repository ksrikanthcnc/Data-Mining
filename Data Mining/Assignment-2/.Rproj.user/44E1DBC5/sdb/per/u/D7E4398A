{
    "collab_server" : "",
    "contents" : "plot.nnet <- function(mod.in,nid=T,all.out=T,all.in=T,bias=T,wts.only=F,rel.rsc=5,circle.cex=5,\n                      node.labs=T,var.labs=T,x.lab=NULL,y.lab=NULL,line.stag=NULL,struct=NULL,cex.val=1,\n                      alpha.val=1,circle.col='lightblue',pos.col='black',neg.col='grey', max.sp = F, ...){\n  \n  require(scales)\n  \n  #sanity checks\n  if('mlp' %in% class(mod.in)) warning('Bias layer not applicable for rsnns object')\n  if('numeric' %in% class(mod.in)){\n    if(is.null(struct)) stop('Three-element vector required for struct')\n    if(length(mod.in) != ((struct[1]*struct[2]+struct[2]*struct[3])+(struct[3]+struct[2])))\n      stop('Incorrect length of weight matrix for given network structure')\n  }\n  if('train' %in% class(mod.in)){\n    if('nnet' %in% class(mod.in$finalModel)){\n      mod.in<-mod.in$finalModel\n      warning('Using best nnet model from train output')\n    }\n    else stop('Only nnet method can be used with train object')\n  }\n  \n  #gets weights for neural network, output is list\n  #if rescaled argument is true, weights are returned but rescaled based on abs value\n  nnet.vals<-function(mod.in,nid,rel.rsc,struct.out=struct){\n    \n    require(scales)\n    require(reshape)\n    \n    if('numeric' %in% class(mod.in)){\n      struct.out<-struct\n      wts<-mod.in\n    }\n    \n    #neuralnet package\n    if('nn' %in% class(mod.in)){\n      struct.out<-unlist(lapply(mod.in$weights[[1]],ncol))\n      struct.out<-struct.out[-length(struct.out)]\n      struct.out<-c(\n        length(mod.in$model.list$variables),\n        struct.out,\n        length(mod.in$model.list$response)\n      )    \t\t\n      wts<-unlist(mod.in$weights[[1]])   \n    }\n    \n    #nnet package\n    if('nnet' %in% class(mod.in)){\n      struct.out<-mod.in$n\n      wts<-mod.in$wts\n    }\n    \n    #RSNNS package\n    if('mlp' %in% class(mod.in)){\n      struct.out<-c(mod.in$nInputs,mod.in$archParams$size,mod.in$nOutputs)\n      hid.num<-length(struct.out)-2\n      wts<-mod.in$snnsObject$getCompleteWeightMatrix()\n      \n      #get all input-hidden and hidden-hidden wts\n      inps<-wts[grep('Input',row.names(wts)),grep('Hidden_2',colnames(wts)),drop=F]\n      inps<-melt(rbind(rep(NA,ncol(inps)),inps))$value\n      uni.hids<-paste0('Hidden_',1+seq(1,hid.num))\n      for(i in 1:length(uni.hids)){\n        if(is.na(uni.hids[i+1])) break\n        tmp<-wts[grep(uni.hids[i],rownames(wts)),grep(uni.hids[i+1],colnames(wts)),drop=F]\n        inps<-c(inps,melt(rbind(rep(NA,ncol(tmp)),tmp))$value)\n      }\n      \n      #get connections from last hidden to output layers\n      outs<-wts[grep(paste0('Hidden_',hid.num+1),row.names(wts)),grep('Output',colnames(wts)),drop=F]\n      outs<-rbind(rep(NA,ncol(outs)),outs)\n      \n      #weight vector for all\n      wts<-c(inps,melt(outs)$value)\n      assign('bias',F,envir=environment(nnet.vals))\n    }\n    \n    if(nid) wts<-rescale(abs(wts),c(1,rel.rsc))\n    \n    #convert wts to list with appropriate names \n    hid.struct<-struct.out[-c(length(struct.out))]\n    row.nms<-NULL\n    for(i in 1:length(hid.struct)){\n      if(is.na(hid.struct[i+1])) break\n      row.nms<-c(row.nms,rep(paste('hidden',i,seq(1:hid.struct[i+1])),each=1+hid.struct[i]))\n    }\n    row.nms<-c(\n      row.nms,\n      rep(paste('out',seq(1:struct.out[length(struct.out)])),each=1+struct.out[length(struct.out)-1])\n    )\n    out.ls<-data.frame(wts,row.nms)\n    out.ls$row.nms<-factor(row.nms,levels=unique(row.nms),labels=unique(row.nms))\n    out.ls<-split(out.ls$wts,f=out.ls$row.nms)\n    \n    assign('struct',struct.out,envir=environment(nnet.vals))\n    \n    out.ls\n    \n  }\n  \n  wts<-nnet.vals(mod.in,nid=F)\n  \n  if(wts.only) return(wts)\n  \n  #circle colors for input, if desired, must be two-vector list, first vector is for input layer\n  if(is.list(circle.col)){\n    circle.col.inp<-circle.col[[1]]\n    circle.col<-circle.col[[2]]\n  }\n  else circle.col.inp<-circle.col\n  \n  #initiate plotting\n  x.range<-c(0,100)\n  y.range<-c(0,100)\n  #these are all proportions from 0-1\n  if(is.null(line.stag)) line.stag<-0.011*circle.cex/2\n  layer.x<-seq(0.17,0.9,length=length(struct))\n  bias.x<-layer.x[-length(layer.x)]+diff(layer.x)/2\n  bias.y<-0.95\n  circle.cex<-circle.cex\n  \n  #get variable names from mod.in object\n  #change to user input if supplied\n  if('numeric' %in% class(mod.in)){\n    x.names<-paste0(rep('X',struct[1]),seq(1:struct[1]))\n    y.names<-paste0(rep('Y',struct[3]),seq(1:struct[3]))\n  }\n  if('mlp' %in% class(mod.in)){\n    all.names<-mod.in$snnsObject$getUnitDefinitions()\n    x.names<-all.names[grep('Input',all.names$unitName),'unitName']\n    y.names<-all.names[grep('Output',all.names$unitName),'unitName']\n  }\n  if('nn' %in% class(mod.in)){\n    x.names<-mod.in$model.list$variables\n    y.names<-mod.in$model.list$respons\n  }\n  if('xNames' %in% names(mod.in)){\n    x.names<-mod.in$xNames\n    y.names<-attr(terms(mod.in),'factor')\n    y.names<-row.names(y.names)[!row.names(y.names) %in% x.names]\n  }\n  if(!'xNames' %in% names(mod.in) & 'nnet' %in% class(mod.in)){\n    if(is.null(mod.in$call$formula)){\n      x.names<-colnames(eval(mod.in$call$x))\n      y.names<-colnames(eval(mod.in$call$y))\n    }\n    else{\n      forms<-eval(mod.in$call$formula)\n      x.names<-mod.in$coefnames\n      facts<-attr(terms(mod.in),'factors')\n      y.check<-mod.in$fitted\n      if(ncol(y.check)>1) y.names<-colnames(y.check)\n      else y.names<-as.character(forms)[2]\n    } \n  }\n  #change variables names to user sub \n  if(!is.null(x.lab)){\n    if(length(x.names) != length(x.lab)) stop('x.lab length not equal to number of input variables')\n    else x.names<-x.lab\n  }\n  if(!is.null(y.lab)){\n    if(length(y.names) != length(y.lab)) stop('y.lab length not equal to number of output variables')\n    else y.names<-y.lab\n  }\n  \n  #initiate plot\n  plot(x.range,y.range,type='n',axes=F,ylab='',xlab='',...)\n  \n  #function for getting y locations for input, hidden, output layers\n  #input is integer value from 'struct'\n  get.ys<-function(lyr, max_space = max.sp){\n    if(max_space){ \n      spacing <- diff(c(0*diff(y.range),0.9*diff(y.range)))/lyr\n    } else {\n      spacing<-diff(c(0*diff(y.range),0.9*diff(y.range)))/max(struct)\n    }\n    \n    seq(0.5*(diff(y.range)+spacing*(lyr-1)),0.5*(diff(y.range)-spacing*(lyr-1)),\n        length=lyr)\n  }\n  \n  #function for plotting nodes\n  #'layer' specifies which layer, integer from 'struct'\n  #'x.loc' indicates x location for layer, integer from 'layer.x'\n  #'layer.name' is string indicating text to put in node\n  layer.points<-function(layer,x.loc,layer.name,cex=cex.val){\n    x<-rep(x.loc*diff(x.range),layer)\n    y<-get.ys(layer)\n    points(x,y,pch=21,cex=circle.cex,col=in.col,bg=bord.col)\n    if(node.labs) text(x,y,paste(layer.name,1:layer,sep=''),cex=cex.val)\n    if(layer.name=='I' & var.labs) text(x-line.stag*diff(x.range),y,x.names,pos=2,cex=cex.val)      \n    if(layer.name=='O' & var.labs) text(x+line.stag*diff(x.range),y,y.names,pos=4,cex=cex.val)\n  }\n  \n  #function for plotting bias points\n  #'bias.x' is vector of values for x locations\n  #'bias.y' is vector for y location\n  #'layer.name' is  string indicating text to put in node\n  bias.points<-function(bias.x,bias.y,layer.name,cex,...){\n    for(val in 1:length(bias.x)){\n      points(\n        diff(x.range)*bias.x[val],\n        bias.y*diff(y.range),\n        pch=21,col=in.col,bg=bord.col,cex=circle.cex\n      )\n      if(node.labs)\n        text(\n          diff(x.range)*bias.x[val],\n          bias.y*diff(y.range),\n          paste(layer.name,val,sep=''),\n          cex=cex.val\n        )\n    }\n  }\n  \n  #function creates lines colored by direction and width as proportion of magnitude\n  #use 'all.in' argument if you want to plot connection lines for only a single input node\n  layer.lines<-function(mod.in,h.layer,layer1=1,layer2=2,out.layer=F,nid,rel.rsc,all.in,pos.col,\n                        neg.col,...){\n    \n    x0<-rep(layer.x[layer1]*diff(x.range)+line.stag*diff(x.range),struct[layer1])\n    x1<-rep(layer.x[layer2]*diff(x.range)-line.stag*diff(x.range),struct[layer1])\n    \n    if(out.layer==T){\n      \n      y0<-get.ys(struct[layer1])\n      y1<-rep(get.ys(struct[layer2])[h.layer],struct[layer1])\n      src.str<-paste('out',h.layer)\n      \n      wts<-nnet.vals(mod.in,nid=F,rel.rsc)\n      wts<-wts[grep(src.str,names(wts))][[1]][-1]\n      wts.rs<-nnet.vals(mod.in,nid=T,rel.rsc)\n      wts.rs<-wts.rs[grep(src.str,names(wts.rs))][[1]][-1]\n      \n      cols<-rep(pos.col,struct[layer1])\n      cols[wts<0]<-neg.col\n      \n      if(nid) segments(x0,y0,x1,y1,col=cols,lwd=wts.rs)\n      else segments(x0,y0,x1,y1)\n      \n    }\n    \n    else{\n      \n      if(is.logical(all.in)) all.in<-h.layer\n      else all.in<-which(x.names==all.in)\n      \n      y0<-rep(get.ys(struct[layer1])[all.in],struct[2])\n      y1<-get.ys(struct[layer2])\n      src.str<-paste('hidden',layer1)\n      \n      wts<-nnet.vals(mod.in,nid=F,rel.rsc)\n      wts<-unlist(lapply(wts[grep(src.str,names(wts))],function(x) x[all.in+1]))\n      wts.rs<-nnet.vals(mod.in,nid=T,rel.rsc)\n      wts.rs<-unlist(lapply(wts.rs[grep(src.str,names(wts.rs))],function(x) x[all.in+1]))\n      \n      cols<-rep(pos.col,struct[layer2])\n      cols[wts<0]<-neg.col\n      \n      if(nid) segments(x0,y0,x1,y1,col=cols,lwd=wts.rs)\n      else segments(x0,y0,x1,y1)\n      \n    }\n    \n  }\n  \n  bias.lines<-function(bias.x,mod.in,nid,rel.rsc,all.out,pos.col,neg.col,...){\n    \n    if(is.logical(all.out)) all.out<-1:struct[length(struct)]\n    else all.out<-which(y.names==all.out)\n    \n    for(val in 1:length(bias.x)){\n      \n      wts<-nnet.vals(mod.in,nid=F,rel.rsc)\n      wts.rs<-nnet.vals(mod.in,nid=T,rel.rsc)\n      \n      if(val != length(bias.x)){\n        wts<-wts[grep('out',names(wts),invert=T)]\n        wts.rs<-wts.rs[grep('out',names(wts.rs),invert=T)]\n        sel.val<-grep(val,substr(names(wts.rs),8,8))\n        wts<-wts[sel.val]\n        wts.rs<-wts.rs[sel.val]\n      }\n      \n      else{\n        wts<-wts[grep('out',names(wts))]\n        wts.rs<-wts.rs[grep('out',names(wts.rs))]\n      }\n      \n      cols<-rep(pos.col,length(wts))\n      cols[unlist(lapply(wts,function(x) x[1]))<0]<-neg.col\n      wts.rs<-unlist(lapply(wts.rs,function(x) x[1]))\n      \n      if(nid==F){\n        wts.rs<-rep(1,struct[val+1])\n        cols<-rep('black',struct[val+1])\n      }\n      \n      if(val != length(bias.x)){\n        segments(\n          rep(diff(x.range)*bias.x[val]+diff(x.range)*line.stag,struct[val+1]),\n          rep(bias.y*diff(y.range),struct[val+1]),\n          rep(diff(x.range)*layer.x[val+1]-diff(x.range)*line.stag,struct[val+1]),\n          get.ys(struct[val+1]),\n          lwd=wts.rs,\n          col=cols\n        )\n      }\n      \n      else{\n        segments(\n          rep(diff(x.range)*bias.x[val]+diff(x.range)*line.stag,struct[val+1]),\n          rep(bias.y*diff(y.range),struct[val+1]),\n          rep(diff(x.range)*layer.x[val+1]-diff(x.range)*line.stag,struct[val+1]),\n          get.ys(struct[val+1])[all.out],\n          lwd=wts.rs[all.out],\n          col=cols[all.out]\n        )\n      }\n      \n    }\n  }\n  \n  #use functions to plot connections between layers\n  #bias lines\n  if(bias) bias.lines(bias.x,mod.in,nid=nid,rel.rsc=rel.rsc,all.out=all.out,pos.col=alpha(pos.col,alpha.val),\n                      neg.col=alpha(neg.col,alpha.val))\n  \n  #layer lines, makes use of arguments to plot all or for individual layers\n  #starts with input-hidden\n  #uses 'all.in' argument to plot connection lines for all input nodes or a single node\n  if(is.logical(all.in)){  \n    mapply(\n      function(x) layer.lines(mod.in,x,layer1=1,layer2=2,nid=nid,rel.rsc=rel.rsc,\n                              all.in=all.in,pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val)),\n      1:struct[1]\n    )\n  }\n  else{\n    node.in<-which(x.names==all.in)\n    layer.lines(mod.in,node.in,layer1=1,layer2=2,nid=nid,rel.rsc=rel.rsc,all.in=all.in,\n                pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val))\n  }\n  #connections between hidden layers\n  lays<-split(c(1,rep(2:(length(struct)-1),each=2),length(struct)),\n              f=rep(1:(length(struct)-1),each=2))\n  lays<-lays[-c(1,(length(struct)-1))]\n  for(lay in lays){\n    for(node in 1:struct[lay[1]]){\n      layer.lines(mod.in,node,layer1=lay[1],layer2=lay[2],nid=nid,rel.rsc=rel.rsc,all.in=T,\n                  pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val))\n    }\n  }\n  #lines for hidden-output\n  #uses 'all.out' argument to plot connection lines for all output nodes or a single node\n  if(is.logical(all.out))\n    mapply(\n      function(x) layer.lines(mod.in,x,layer1=length(struct)-1,layer2=length(struct),out.layer=T,nid=nid,rel.rsc=rel.rsc,\n                              all.in=all.in,pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val)),\n      1:struct[length(struct)]\n    )\n  else{\n    node.in<-which(y.names==all.out)\n    layer.lines(mod.in,node.in,layer1=length(struct)-1,layer2=length(struct),out.layer=T,nid=nid,rel.rsc=rel.rsc,\n                pos.col=pos.col,neg.col=neg.col,all.out=all.out)\n  }\n  \n  #use functions to plot nodes\n  for(i in 1:length(struct)){\n    in.col<-bord.col<-circle.col\n    layer.name<-'H'\n    if(i==1) { layer.name<-'I'; in.col<-bord.col<-circle.col.inp}\n    if(i==length(struct)) layer.name<-'O'\n    layer.points(struct[i],layer.x[i],layer.name)\n  }\n  \n  if(bias) bias.points(bias.x,bias.y,'B')\n  \n}",
    "created" : 1509291984075.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1633903939",
    "id" : "D7E4398A",
    "lastKnownWriteTime" : 3252480877701112320,
    "last_content_update" : 1509291985802,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}